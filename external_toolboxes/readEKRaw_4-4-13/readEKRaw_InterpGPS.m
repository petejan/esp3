function [data, varargout] = readEKRaw_InterpGPS(data, varargin)
%readEKRaw_InterpGPS  Interpolate GPS on a ping-by-ping basis
%   data = readEKRaw_InterpGPS(data, varargin) interpolates GPS fixes on a
%   ping-by-ping basis replacing the original GPS data with the interpolated
%   data.
%
%   NOTE:  BY DEFAULT, NO SANITY CHECKS ARE PERFORMED ON THE GPS DATA.  There aren't
%          any foolproof approaches to removing errant fixes that I have dreamed up
%          so for now I have left this task up to you, the user. I have added a
%          speed based sanity check (see MaxSpeed below) but understand that the
%          primary assumption with this method is that the first few fixes are valid.
%
%   NOTE:  By default, this function will delete pings whose associated GPS data
%          is NaN after interpolation.  Set the KeepAll parameter to disable
%          this behavior.
%
%   NOTE:  This function *deletes pings* that aren't assigned to a segment.  You
%          only need to worry about this if you are using geographic ROI's or
%          have gaps in your data that exceed the length degined in the MaxSegGap
%          parameter in readEKRaw.
%
%   REQUIRED INPUT:
%            data:   The "data" structure output from readEKRaw.  For
%                    smoothing to be effective, lat/lon should be type
%                    double.
%
%   OPTIONAL PARAMETERS:
%         BotData:   Set this parameter to an instance of the readEKRaw sounder
%                    detected bottom data structure to to remove bottom detections
%                    associated with pings that were removed during interpolation.
%                    You must also set an output argument to return the altered
%                    bottom data. This is a convienient method to keep the pings
%                    and bottom detection data structures the same length when
%                    interpolating GPS.
%                           Default: []
%
%         KeepAll:   Set this parameter to true to avoid deleting pings whose
%                    associated GPS fix lies outside the interval spanned by GPS
%                    data (and if using the recommended linear interpolation is
%                    equal to NaN).
%                           Default: false
%
%        MaxSpeed:   Set this parameter to a scalar specifying the maximum
%                    vessel speed  to be used for a speed based sanity
%                    check.  If the apparent speed between fix N and fix N+1
%                    exceeds this value fix N+1 will be dropped and the speed
%                    between N and N+2 will be calculated and checked.
%                         THIS IS EXPERIMENTAL AND UNDER DEVELOPMENT
%                    Set this to 0 to disable speed checks
%                           Default: 0
%
%          Method:   Set this parameter to the desired interpolation method.
%                    Valid methods are 'nearest', 'linear', 'spline', and 
%                    'cubic'.  For descriptions, see the MATLAB docs for
%                    interp1.
%
%                    Note that for linear, nearest, and v5cubic pings
%                    outside of the interval spanned by the GPS data will be
%                    dropped as their GPS fixes will be NaN.  The other methods 
%                    will extrapolate GPS fixes
%                           Default: 'linear'
%
%          Smooth:   Set this parameter to specify the width of the smoothing
%                    window used in applying a running mean to the GPS
%                    data. Smoothing is only used when calculating cumulative
%                    distance and speed. THE GPS DATA ARE NOT SMOOTHED PRIOR TO
%                    INTERPOLATION. A value of 0 disables smoothing.  Negative values
%                    will enable "edge_trucation" when smoothing.
%                           Default: 5
%
%  CumulativeDist:   Set this parameter to true to return an additional field
%                    "cdist" containing the cumulative distance from ping to ping
%                    in nmi.  Distance calculation is done using Vincenty's
%                    algorithm (see vdist.m for details).  This is similar to
%                    the VLW NMEA datagram generated by GPS receivers and 
%                    Simrad's ER60 software.
%
%                    Note that cumulative distances are calculated w/in 
%                    segments.
%                           Default: false
%
%         CDStart:  Set this parameter to a scalar defining the starting
%                   cumulative distance value.
%
%                   If calculating cdist with segmented data, CDStart is applied
%                   only to the first segment, the subsequent segments start
%                   accumulating where the prior segment ended.
%                           Default: 0
%
%     VesselSpeed:   Set this parameter to 1 to return an additional field
%                    "vspeed" containing the vessel speed over ground in knots
%                    calculated from the GPS fixes and *heavily smoothed*.
%                    Set this parameter to 2 to return vessel speed that is
%                    unsmoothed.
%                           Default: false
%
%       
%   OUTPUT:
%       Output is a modified version of the input data structure where the gps
%       lat and lon fields have been expanded to the same length as
%       data.ping.time.
%
%       Optionally, this function will output a modified bottom detection structure
%       where the number, time, and bottomdepth fields have been trimmed to match
%       the "pings" data structure.
%
%       NOTE:  This function deletes the data.gps.time and data.gps.seg fields
%              since without modification they are meaningless after interpolation
%              and if modified it would simply be a copies of data.ping.time
%              and data.ping.seg
%
%   REQUIRES:
%               vdist_vect.m
%

%   Rick Towler
%   National Oceanic and Atmospheric Administration
%   Alaska Fisheries Science Center
%   Midwater Assesment and Conservation Engineering Group
%   rick.towler@noaa.gov

%-

%  check if the gps fields exists
if (~isfield(data, 'gps'))
    warning ('readEKRaw:ParameterError', ...
        'GPS field does not exist in data structure.');
    return
end

%  define defaults
method = 'linear';              %  default interpolation method is spline
edgeTruncate = false;           %  default is to not enable edgeTrucation
keepAll = false;                %  default is to delete pings where GPS==NaN
swin = 5;                       %  default smoothing window of 6 pings
cdist = false;                  %  default is to not return cumulative distance
cdStart = 0;                    %  default is to not add offset to cdist
vspeed = 0;                     %  default is to not return vessel speed
maxSpeed = 0;
botData = [];

%  process optional parameters
for n = 1:2:length(varargin)
    switch lower(varargin{n})
        case 'botdata'
            botData = varargin{n + 1};
        case 'method'
            method = varargin{n + 1};
        case 'keepall'
            keepAll = 0 < varargin{n + 1};
        case 'smooth'
            swin = varargin{n + 1};
            if (swin > 0)
                edgeTruncate = false;
            else
                swin = abs(swin);
                edgeTruncate = true;
            end
        case 'cumulativedist'
            cdist = varargin{n + 1};
        case 'maxspeed'
            maxSpeed = varargin{n + 1};
        case 'cdstart'
            cdStart = varargin{n + 1};
        case 'vesselspeed'
            switch true
                case varargin{n + 1} <= 0
                    vspeed = 0;
                case varargin{n + 1} == 1
                    vspeed = 1;
                case varargin{n + 1} > 1
                    vspeed = 2;   
            end
        otherwise
            warning('readEKRaw:ParameterError', ['Unknown property name: ' ...
                varargin{n}]);
    end
end

%  determine number of frequencies
nFreqs = length(data.pings);

%  delete "orphan" pings (pings not assigned to segment)
pIDX = find(data.pings(1).seg == 0);
for n=1:nFreqs
    data.pings(n) = readEKRaw_DeletePing(data.pings(n), pIDX);
    if ~isempty(botData)
        botData.pings(n) = readEKRaw_DeleteBot(botData.pings(n), pIDX);
    end
end

%  determine segment count
nsegStart = min(data.gps.seg(data.gps.seg > 0));
nsegEnd = max(data.gps.seg);

%  get total number of pings over all segments
nPings = length(data.pings(1).time);

%  create temporary lat/lon arrays
latTemp = zeros(nPings, 1, class(data.gps.lat));
lonTemp = zeros(nPings, 1, class(data.gps.lon));

%  create cdist and vspeed arrays if required
if (cdist); data.gps.cdist = zeros(nPings, 1); end
if (vspeed > 0); data.gps.vspeed = zeros(nPings, 1); end

%  loop thru segments, interpolating each
for n=nsegStart:nsegEnd
    
    %  get index into ping data for this segment
    psIDX = find(data.pings(1).seg == n);
    nPingsInSeg = length(psIDX);
    
    %  get index into gps data for this segment
    segIDX = find(data.gps.seg == n);
    nFixesInSeg = length(segIDX);

    %  switch based on the number of GPS fixes
    switch nFixesInSeg
        case 0
            %  no GPS data in file - do nothing

        case 1
            %  not enough fixes to interpolate - replicate
            latTemp(psIDX) = repmat(data.gps.lat(segIDX), 1, nPingsInSeg);
            lonTemp(psIDX) = repmat(data.gps.lon(segIDX), 1, nPingsInSeg);
            
        otherwise
            
            %  check speed - experimental
            if (maxSpeed > 0)
                speedOK = false;
                while (speedOK == false)
                    %  calculate distance between raw fixes
                    distm = vdist_vect(data.gps.lat(segIDX), data.gps.lon(segIDX), ...
                        circshift(data.gps.lat(segIDX),1), circshift(data.gps.lon(segIDX), 1));
                    distm(1) = 0;
                    %  remove NaNs due to lack of movement.
                    distm(isnan(distm)) = 0;

                    %  calculate elapsed time in seconds
                    etime = [0;diff(data.gps.time(segIDX))] * 86400;
                    %  calculate vessel speed in knots
                    speed = (distm ./ etime) * 1.94384449;
                    
                    %  check the speed
                    tooFast = speed > maxSpeed;
                    if any(tooFast)
                        % we have bad fixes - remove and re-try
                        segIDX(tooFast) = [];
                        %  if we have a problem with the first pair of fixes remove both
                        if (tooFast(2)); segIDX(1) = []; end
                    else
                        %  all speeds are below maximum
                        speedOK = true;
                    end
                end
            end
            
            %  interpolate. - Remove non-unique X values (and their Y counterparts)
            [x, ax, ~] = unique(data.gps.time(segIDX));
            y = data.gps.lat(segIDX);
            y = y(ax);
            latTemp(psIDX) = interp1(x, y, data.pings(1).time(psIDX), method);
            y = data.gps.lon(segIDX);
            y = y(ax);
            lonTemp(psIDX) = interp1(x, y, data.pings(1).time(psIDX), method);

            % smooth GPS data
            if (swin > 1)
                data.gps.lat(segIDX) = readEKRaw_Smooth(data.gps.lat(segIDX), ...
                    swin, 'EdgeTruncate', edgeTruncate);
                data.gps.lon(segIDX) = readEKRaw_Smooth(data.gps.lon(segIDX), ...
                    swin, 'EdgeTruncate', edgeTruncate);
            end
            
            %  calculate cumulative distance and vspeed
            if (cdist || (vspeed > 0))
                %  calculate distance travelled in m
                
                %  create an array to hold distances for this segment
                distm = zeros(nPingsInSeg, 1);
                %  identify NaNs in interpolated fixes for this segment
                gpNaN = isnan(latTemp(psIDX));
                %  get an logical array of NON-NaN fixes for this segment
                dIDX = psIDX(~gpNaN);
                %  create an index array of NON-NaN fixes *relative to this segment*
                drIDX = dIDX - psIDX(1) + 1;
                %  calculate distances between non-NaN fixes
                distm(drIDX) = vdist_vect(latTemp(dIDX), lonTemp(dIDX), ...
                    circshift(latTemp(dIDX),1), circshift(lonTemp(dIDX), 1));
                %  first distance is always 0
                distm(drIDX(1)) = 0;
                
                %  shouldn't need this line as these values are already 0
                %distm(psIDX(gpNaN)) = 0;
                
                %  remove NaNs due to lack of movement.
                distm(isnan(distm)) = 0;

                if (vspeed > 0)
                    %  calculate elapsed time in seconds
                    etime = [0 diff(data.pings(1).time(psIDX))]' * 86400;
                    %  calculate vessel speed in knots
                    data.gps.etime = etime;
                    data.gps.distm = distm;
                    data.gps.vspeed(psIDX) = (distm ./ etime) * 1.94384449;
                end
                
                if (cdist)
                    %  calculate cumulative distance
                    data.gps.cdist(psIDX) = (cumsum(distm) / 1852) + cdStart;
                    cdStart = data.gps.cdist(psIDX(end));
                end
            end
    end
end

%  replace gps data
data.gps.lat = latTemp;
data.gps.lon = lonTemp;

if (~keepAll)
    % remove interpolated GPS fixes outside of valid GPS interval
    gpNaN = isnan(data.gps.lat);
    data.gps.lat(gpNaN) = [];
    data.gps.lon(gpNaN) = [];
    if (vspeed > 0); data.gps.vspeed(gpNaN) = []; end
    if (cdist); data.gps.cdist(gpNaN) = []; end

    %  remove pings outside of valid GPS interval
    pIDX = find(gpNaN == 1);
    nFreqs = length(data.pings);
    for n=1:nFreqs
        data.pings(n) = readEKRaw_DeletePing(data.pings(n), pIDX);
        if ~isempty(botData)
            botData.pings(n) = readEKRaw_DeleteBot(botData.pings(n), pIDX);
        end
    end
end

if ~isempty(botData); varargout = {botData}; end

%  assume vspeed at GPS fix 1 is the same as speed at GPS fix 2
if (vspeed > 0); data.gps.vspeed(1) = data.gps.vspeed(2); end
    
%  smooth vspeed in 3 passes
if (vspeed == 1)
    nvs = length(data.gps.vspeed);
    if (nvs > 5); data.gps.vspeed = readEKRaw_Smooth(data.gps.vspeed, 5, ...
         'EdgeTruncate', true); end
    if (nvs > 15); data.gps.vspeed = readEKRaw_Smooth(data.gps.vspeed, 15, ...
         'EdgeTruncate', true); end
    if (nvs > 25); data.gps.vspeed = readEKRaw_Smooth(data.gps.vspeed, 25, ...
         'EdgeTruncate', false); end
end

%  remove time and seg fields from GPS
data.gps = rmfield(data.gps, 'time');
data.gps = rmfield(data.gps, 'seg');
